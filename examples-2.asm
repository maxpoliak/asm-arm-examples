
		; Процедура копирования фаила в буфер.
		SECTION .CoreSysetem:CODE:NOROOT(2)
		PUBLIC __CreateDataFile
		PUBLIC __LenStr
		PUBLIC __ScnStr
		ARM

		; Процедура __CreateDataFile заполняет структуру данных типа CORESSYSDATA по адресу
		; pfilepointer - адрес в памяти для создания фаила для хранения информации
;typedef struct
;{
;	pDWORD * pdata;			// указатель на данные data[size]
;	FSIZE size;			// размер массива
;	BYTE fmane[] = "Name of file";	// массив байтов строки
;	DWORD data[size];		// массив данных
;}
;SYSTEMDATAFILE

;typedef struct
;{
;	DWORD size;			//размер фаила данных
;	DWORD data[size];
;}
;DATABUFFER

;__asm pDWORD * __CreateDataFile( pDWORD * pfilepointer; TEXT * filename; DATABUFFER * pbuf)
__CreateDataFile:
		PUSH	{r4-r6}
		MOV	r6, #0
		MOV     r4, r0			;сохранить базовый адрес фаила
		ADD	r0, r0, #8		;смещение адреса до стоки имени фаила
		ADD	r5, r0,	#4		;сохранить базовый адрес строки имени фаила
writename:
		LDRB	r3,	[r1], #1	;загрузить очередной байт строки fmane[]
		CMP 	r3, #0			;сравнить с 0, выставить флаги
		BEQ	exitwritename		;выйти из цикла создания строки имени фаила
		STRB	r3, [r0], #1		;сохранить байт строки
		ADD	r6, r6, #1
		B	writename		;в начало цикла
exitwritename:
		MOV	r0, r0, LSR 2
		MOV	r0, r0, LSL 2		;выровнить адрес
		ADD	r0, r0, #4
		STR	r0, [r4], #4		;сохранить указатель на массив данных
		LDR	r5,	[r2], #4	;загрузить в r5 размер массива данных
		STR	r5, [r4]		;сохранить размер массива в SYSTEMDATAFILE
storedata:
		LDR	r4, [r2], #4		;копировать из буфера данные в фаил
		STR	r4, [r0], #4
		SUBS	r5, r5, #1		;декрементировать счетчик цикла, выставить флаги
		BEQ	exitstoredata		;если весь массив записан, перейти к завершению процедуры
		B	storedata		;если нет, то перейти в начало цикла
exitstoredata:
		POP	{r4-r6}
		BX	lr			;выйти из подпрограммы


		;__LenStr определяет длину строки. Принимает параметр TEXT *s - указатель
		;на строку. Возвращает количество символов
;__asm DWORD __LenStr( TEXT * s );

__LenStr:
loopLenStr:
		LDRB	r1, [r0], #1		;загрузить байт строки
		CMP	r1, #0			;проверить наличие завершающего нуля, выставить флаги
		ADDNE 	r2, r2, #1		;инкрементировать счетчик символов, если != 0
		BNE	loopLenStr		;вернуться в начало, если != 0
		MOV	r0, r2			;если 0, вернуть количество символов
		BX	lr			;и выйти из подпрограммы


		;Процедура __ScnStr ищет первое появление в строке TEXT *s символа с,
		;возвращает индекс символа, если он найден, индекс завершающего нуля
;__asm pDWORD * __ScnStr( TEXT * s, TEXT c )

__ScnStr:
		LDRB	r2, [r0]		;загрузить первый символ строки
loopScnStr:
		CMP	r2, #0			;сравнить с нулем
		BEQ	exitScnStr		;если равно, выйти
		CMP	r2, r1			;сравнить символы
		BEQ	exitScnStr		;если совпадают, выйти
		LDRB	r2, [r0, #1]!		;если не совпадают, загрузить следующий байт
		B	loopScnStr		;и перейти в начало
exitScnStr:
		BX	lr			;в противном случае выйти из подпрограммы

		;Процедура __SubStr ищет подстроку TEXT * ps в строке TEXT * s
		;возвращает указатель на подстроку в стоке при совпадении, в ином случае адрес
		;завершающего нуля
;__asm pDWORD * __ScnStr( TEXT * s, TEXT * ps )

__SubStr:
		PUSH	{r4}
		LDRB	r2, [r0]		;загрузить первый байт строки *s
		LDRB	r3, [r1]		;загрузить первый байт подстроки *ps
loopSub:
		CMP	r2, #0			;проверить, не является ли завершающим 0
		BEQ	exitSubStr		;если 0, перейти в конец подпрограммы
		CMP	r2, r3			;сравнить два символа, выставить флаги
		MOVEQ	r4, r0			;если произошло совпадение, то скопировать адрес
		BEQ	nextSub			;совпадения в строке *s и перейти к следующему символу
		LDRB	r2, [r0, #1]!		;загрузить следующий байт строки *s
		LDRB	r3, [r1, #1]!		;загрузить следующий байт подстроки *ps
		B	loopSub			;перейти в начало цикла
nextSub:
		LDRB	r2, [r0, #1]!		;загрузить следующий байт строки *s
		LDRB	r3, [r1, #1]!		;загрузить следующий байт подстроки *ps
		CMP	r2, #0			;сравнить с завершающим нулем
		BEQ	exitSubStr		;если нуль, перейти в конец подпрограммы
		CMP	r3, #0			;проверить, не является ли завершающим нулем
		BEQ	compSubStr		;если нуль, перейти в конец подпрограммы
		CMP	r2, r3			;сравнить два символа
		BEQ	nextSub			;при совпадении перейти для проверки след. символа
		B	loopSub			;в противном случае перейти в начало подпрограммы
compSubStr:
		MOV	r0, r4			;восстановить указатель на совпадения в строке
exitSubStr:
		POP	{r4}
		BX	lr

		END
